/**
 * jVectorMap version 1.1.1
 *
 * Copyright 2011-2012, Kirill Lebedev
 * Licensed under the MIT license.
 *
 */(function(a) {
    var b = {
        set: {
            colors: 1,
            values: 1,
            backgroundColor: 1,
            scaleColors: 1,
            normalizeFunction: 1,
            focus: 1
        },
        get: {
            selectedRegions: 1,
            selectedMarkers: 1,
            mapObject: 1,
            regionName: 1
        }
    };
    a.fn.vectorMap = function(a) {
        var c, d, e, c = this.children(".jvectormap-container").data("mapObject");
        if (a === "addMap") {
            jvm.WorldMap.maps[arguments[1]] = arguments[2];
        } else if ((a === "set" || a === "get") && b[a][arguments[1]]) {
            d = arguments[1].charAt(0).toUpperCase() + arguments[1].substr(1);
            return c[a + d].apply(c, Array.prototype.slice.call(arguments, 2));
        } else {
            a = a || {};
            a.container = this;
            c = new jvm.WorldMap(a);
        }
        return this;
    };
})(jQuery);

(function(a) {
    function d(b) {
        var c = b || window.event, d = [].slice.call(arguments, 1), e = 0, f = true, g = 0, h = 0;
        b = a.event.fix(c);
        b.type = "mousewheel";
        if (c.wheelDelta) {
            e = c.wheelDelta / 120;
        }
        if (c.detail) {
            e = -c.detail / 3;
        }
        h = e;
        if (c.axis !== undefined && c.axis === c.HORIZONTAL_AXIS) {
            h = 0;
            g = -1 * e;
        }
        if (c.wheelDeltaY !== undefined) {
            h = c.wheelDeltaY / 120;
        }
        if (c.wheelDeltaX !== undefined) {
            g = -1 * c.wheelDeltaX / 120;
        }
        d.unshift(b, e, g, h);
        return (a.event.dispatch || a.event.handle).apply(this, d);
    }
    var b = [ "DOMMouseScroll", "mousewheel" ];
    if (a.event.fixHooks) {
        for (var c = b.length; c; ) {
            a.event.fixHooks[b[--c]] = a.event.mouseHooks;
        }
    }
    a.event.special.mousewheel = {
        setup: function() {
            if (this.addEventListener) {
                for (var a = b.length; a; ) {
                    this.addEventListener(b[--a], d, false);
                }
            } else {
                this.onmousewheel = d;
            }
        },
        teardown: function() {
            if (this.removeEventListener) {
                for (var a = b.length; a; ) {
                    this.removeEventListener(b[--a], d, false);
                }
            } else {
                this.onmousewheel = null;
            }
        }
    };
    a.fn.extend({
        mousewheel: function(a) {
            return a ? this.bind("mousewheel", a) : this.trigger("mousewheel");
        },
        unmousewheel: function(a) {
            return this.unbind("mousewheel", a);
        }
    });
})(jQuery);

var jvm = {
    inherits: function(a, b) {
        function c() {}
        c.prototype = b.prototype;
        a.prototype = new c;
        a.prototype.constructor = a;
        a.parentClass = b;
    },
    mixin: function(a, b) {
        var c;
        for (c in b.prototype) {
            if (b.prototype.hasOwnProperty(c)) {
                a.prototype[c] = b.prototype[c];
            }
        }
    },
    min: function(a) {
        var b = Number.MAX_VALUE, c;
        if (a instanceof Array) {
            for (c = 0; c < a.length; c++) {
                if (a[c] < b) {
                    b = a[c];
                }
            }
        } else {
            for (c in a) {
                if (a[c] < b) {
                    b = a[c];
                }
            }
        }
        return b;
    },
    max: function(a) {
        var b = Number.MIN_VALUE, c;
        if (a instanceof Array) {
            for (c = 0; c < a.length; c++) {
                if (a[c] > b) {
                    b = a[c];
                }
            }
        } else {
            for (c in a) {
                if (a[c] > b) {
                    b = a[c];
                }
            }
        }
        return b;
    },
    keys: function(a) {
        var b = [], c;
        for (c in a) {
            b.push(c);
        }
        return b;
    },
    values: function(a) {
        var b = [], c, d;
        for (d = 0; d < arguments.length; d++) {
            a = arguments[d];
            for (c in a) {
                b.push(a[c]);
            }
        }
        return b;
    }
};

jvm.$ = jQuery;

jvm.AbstractElement = function(a, b) {
    this.node = this.createElement(a);
    this.name = a;
    this.properties = {};
    if (b) {
        this.set(b);
    }
};

jvm.AbstractElement.prototype.set = function(a, b) {
    var c;
    if (typeof a === "object") {
        for (c in a) {
            this.properties[c] = a[c];
            this.applyAttr(c, a[c]);
        }
    } else {
        this.properties[a] = b;
        this.applyAttr(a, b);
    }
};

jvm.AbstractElement.prototype.get = function(a) {
    return this.properties[a];
};

jvm.AbstractElement.prototype.applyAttr = function(a, b) {
    this.node.setAttribute(a, b);
};

jvm.AbstractElement.prototype.remove = function() {
    jvm.$(this.node).remove();
};

jvm.AbstractCanvasElement = function(a, b, c) {
    this.container = a;
    this.setSize(b, c);
    this.rootElement = new jvm[this.classPrefix + "GroupElement"];
    this.node.appendChild(this.rootElement.node);
    this.container.appendChild(this.node);
};

jvm.AbstractCanvasElement.prototype.add = function(a, b) {
    b = b || this.rootElement;
    b.add(a);
    a.canvas = this;
};

jvm.AbstractCanvasElement.prototype.addPath = function(a, b, c) {
    var d = new jvm[this.classPrefix + "PathElement"](a, b);
    this.add(d, c);
    return d;
};

jvm.AbstractCanvasElement.prototype.addCircle = function(a, b, c) {
    var d = new jvm[this.classPrefix + "CircleElement"](a, b);
    this.add(d, c);
    return d;
};

jvm.AbstractCanvasElement.prototype.addGroup = function(a) {
    var b = new jvm[this.classPrefix + "GroupElement"];
    if (a) {
        a.node.appendChild(b.node);
    } else {
        this.node.appendChild(b.node);
    }
    b.canvas = this;
    return b;
};

jvm.AbstractShapeElement = function(a, b, c) {
    this.style = c || {};
    this.style.current = {};
    this.isHovered = false;
    this.isSelected = false;
    this.updateStyle();
};

jvm.AbstractShapeElement.prototype.setHovered = function(a) {
    if (this.isHovered !== a) {
        this.isHovered = a;
        this.updateStyle();
    }
};

jvm.AbstractShapeElement.prototype.setSelected = function(a) {
    if (this.isSelected !== a) {
        this.isSelected = a;
        this.updateStyle();
        jvm.$(this.node).trigger("selected", [ a ]);
    }
};

jvm.AbstractShapeElement.prototype.setStyle = function(a, b) {
    var c = {};
    if (typeof a === "object") {
        c = a;
    } else {
        c[a] = b;
    }
    jvm.$.extend(this.style.current, c);
    this.updateStyle();
};

jvm.AbstractShapeElement.prototype.updateStyle = function() {
    var a = {};
    jvm.$.extend(a, this.style.initial || {});
    jvm.$.extend(a, this.style.current || {});
    if (this.isHovered) {
        jvm.$.extend(a, this.style.hover || {});
    }
    if (this.isSelected) {
        jvm.$.extend(a, this.style.selected || {});
        if (this.isHovered) {
            jvm.$.extend(a, this.style.selectedHover || {});
        }
    }
    this.set(a);
};

jvm.SVGElement = function(a, b) {
    jvm.SVGElement.parentClass.apply(this, arguments);
};

jvm.inherits(jvm.SVGElement, jvm.AbstractElement);

jvm.SVGElement.svgns = "http://www.w3.org/2000/svg";

jvm.SVGElement.prototype.createElement = function(a) {
    return document.createElementNS(jvm.SVGElement.svgns, a);
};

jvm.SVGElement.prototype.addClass = function(a) {
    this.node.setAttribute("class", a);
};

jvm.SVGElement.prototype.getElementCtr = function(a) {
    return jvm["SVG" + a];
};

jvm.SVGElement.prototype.getBBox = function() {
    return this.node.getBBox();
};

jvm.SVGGroupElement = function() {
    jvm.SVGGroupElement.parentClass.call(this, "g");
};

jvm.inherits(jvm.SVGGroupElement, jvm.SVGElement);

jvm.SVGGroupElement.prototype.add = function(a) {
    this.node.appendChild(a.node);
};

jvm.SVGCanvasElement = function(a, b, c) {
    this.classPrefix = "SVG";
    jvm.SVGCanvasElement.parentClass.call(this, "svg");
    jvm.AbstractCanvasElement.apply(this, arguments);
};

jvm.inherits(jvm.SVGCanvasElement, jvm.SVGElement);

jvm.mixin(jvm.SVGCanvasElement, jvm.AbstractCanvasElement);

jvm.SVGCanvasElement.prototype.setSize = function(a, b) {
    this.width = a;
    this.height = b;
    this.node.setAttribute("width", a);
    this.node.setAttribute("height", b);
};

jvm.SVGCanvasElement.prototype.applyTransformParams = function(a, b, c) {
    this.scale = a;
    this.transX = b;
    this.transY = c;
    this.rootElement.node.setAttribute("transform", "scale(" + a + ") translate(" + b + ", " + c + ")");
};

jvm.SVGShapeElement = function(a, b, c) {
    jvm.SVGShapeElement.parentClass.call(this, a, b);
    jvm.AbstractShapeElement.apply(this, arguments);
};

jvm.inherits(jvm.SVGShapeElement, jvm.SVGElement);

jvm.mixin(jvm.SVGShapeElement, jvm.AbstractShapeElement);

jvm.SVGPathElement = function(a, b) {
    jvm.SVGPathElement.parentClass.call(this, "path", a, b);
    this.node.setAttribute("fill-rule", "evenodd");
};

jvm.inherits(jvm.SVGPathElement, jvm.SVGShapeElement);

jvm.SVGCircleElement = function(a, b) {
    jvm.SVGCircleElement.parentClass.call(this, "circle", a, b);
};

jvm.inherits(jvm.SVGCircleElement, jvm.SVGShapeElement);

jvm.VMLElement = function(a, b) {
    if (!jvm.VMLElement.VMLInitialized) {
        jvm.VMLElement.initializeVML();
    }
    jvm.VMLElement.parentClass.apply(this, arguments);
};

jvm.inherits(jvm.VMLElement, jvm.AbstractElement);

jvm.VMLElement.VMLInitialized = false;

jvm.VMLElement.initializeVML = function() {
    try {
        if (!document.namespaces.rvml) {
            document.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
        }
        jvm.VMLElement.prototype.createElement = function(a) {
            return document.createElement("<rvml:" + a + ' class="rvml">');
        };
    } catch (a) {
        jvm.VMLElement.prototype.createElement = function(a) {
            return document.createElement("<" + a + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
        };
    }
    document.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
    jvm.VMLElement.VMLInitialized = true;
};

jvm.VMLElement.prototype.getElementCtr = function(a) {
    return jvm["VML" + a];
};

jvm.VMLElement.prototype.addClass = function(a) {
    jvm.$(this.node).addClass(a);
};

jvm.VMLElement.prototype.applyAttr = function(a, b) {
    this.node[a] = b;
};

jvm.VMLElement.prototype.getBBox = function() {
    var a = jvm.$(this.node);
    return {
        x: a.position().left / this.canvas.scale,
        y: a.position().top / this.canvas.scale,
        width: a.width() / this.canvas.scale,
        height: a.height() / this.canvas.scale
    };
};

jvm.VMLGroupElement = function() {
    jvm.VMLGroupElement.parentClass.call(this, "group");
    this.node.style.left = "0px";
    this.node.style.top = "0px";
    this.node.coordorigin = "0 0";
};

jvm.inherits(jvm.VMLGroupElement, jvm.VMLElement);

jvm.VMLGroupElement.prototype.add = function(a) {
    this.node.appendChild(a.node);
};

jvm.VMLCanvasElement = function(a, b, c) {
    this.classPrefix = "VML";
    jvm.VMLCanvasElement.parentClass.call(this, "group");
    jvm.AbstractCanvasElement.apply(this, arguments);
    this.node.style.position = "absolute";
};

jvm.inherits(jvm.VMLCanvasElement, jvm.VMLElement);

jvm.mixin(jvm.VMLCanvasElement, jvm.AbstractCanvasElement);

jvm.VMLCanvasElement.prototype.setSize = function(a, b) {
    var c, d, e, f;
    this.width = a;
    this.height = b;
    this.node.style.width = a + "px";
    this.node.style.height = b + "px";
    this.node.coordsize = a + " " + b;
    this.node.coordorigin = "0 0";
    if (this.rootElement) {
        c = this.rootElement.node.getElementsByTagName("shape");
        for (e = 0, f = c.length; e < f; e++) {
            c[e].coordsize = a + " " + b;
            c[e].style.width = a + "px";
            c[e].style.height = b + "px";
        }
        d = this.node.getElementsByTagName("group");
        for (e = 0, f = d.length; e < f; e++) {
            d[e].coordsize = a + " " + b;
            d[e].style.width = a + "px";
            d[e].style.height = b + "px";
        }
    }
};

jvm.VMLCanvasElement.prototype.applyTransformParams = function(a, b, c) {
    this.scale = a;
    this.transX = b;
    this.transY = c;
    this.rootElement.node.coordorigin = this.width - b - this.width / 100 + "," + (this.height - c - this.height / 100);
    this.rootElement.node.coordsize = this.width / a + "," + this.height / a;
};

jvm.VMLShapeElement = function(a, b) {
    jvm.VMLShapeElement.parentClass.call(this, a, b);
    this.fillElement = new jvm.VMLElement("fill");
    this.strokeElement = new jvm.VMLElement("stroke");
    this.node.appendChild(this.fillElement.node);
    this.node.appendChild(this.strokeElement.node);
    this.node.stroked = false;
    jvm.AbstractShapeElement.apply(this, arguments);
};

jvm.inherits(jvm.VMLShapeElement, jvm.VMLElement);

jvm.mixin(jvm.VMLShapeElement, jvm.AbstractShapeElement);

jvm.VMLShapeElement.prototype.applyAttr = function(a, b) {
    switch (a) {
      case "fill":
        this.node.fillcolor = b;
        break;
      case "fill-opacity":
        this.fillElement.node.opacity = Math.round(b * 100) + "%";
        break;
      case "stroke":
        if (b === "none") {
            this.node.stroked = false;
        } else {
            this.node.stroked = true;
        }
        this.node.strokecolor = b;
        break;
      case "stroke-opacity":
        this.strokeElement.node.opacity = Math.round(b * 100) + "%";
        break;
      case "stroke-width":
        if (parseInt(b, 10) === 0) {
            this.node.stroked = false;
        } else {
            this.node.stroked = true;
        }
        this.node.strokeweight = b;
        break;
      case "d":
        this.node.path = jvm.VMLPathElement.pathSvgToVml(b);
        break;
      default:
        jvm.VMLShapeElement.parentClass.prototype.applyAttr.apply(this, arguments);
    }
};

jvm.VMLPathElement = function(a, b) {
    var c = new jvm.VMLElement("skew");
    jvm.VMLPathElement.parentClass.call(this, "shape", a, b);
    this.node.coordorigin = "0 0";
    c.node.on = true;
    c.node.matrix = "0.01,0,0,0.01,0,0";
    c.node.offset = "0,0";
    this.node.appendChild(c.node);
};

jvm.inherits(jvm.VMLPathElement, jvm.VMLShapeElement);

jvm.VMLPathElement.prototype.applyAttr = function(a, b) {
    if (a === "d") {
        this.node.path = jvm.VMLPathElement.pathSvgToVml(b);
    } else {
        jvm.VMLShapeElement.prototype.applyAttr.call(this, a, b);
    }
};

jvm.VMLPathElement.pathSvgToVml = function(a) {
    var b = "", c = 0, d = 0, e, f;
    a = a.replace(/(-?\d+)e(-?\d+)/g, "0");
    return a.replace(/([MmLlHhVvCcSs])\s*((?:-?\d*(?:\.\d+)?\s*,?\s*)+)/g, function(a, b, g, h) {
        g = g.replace(/(\d)-/g, "$1,-").replace(/^\s+/g, "").replace(/\s+$/g, "").replace(/\s+/g, ",").split(",");
        if (!g[0]) g.shift();
        for (var i = 0, j = g.length; i < j; i++) {
            g[i] = Math.round(100 * g[i]);
        }
        switch (b) {
          case "m":
            c += g[0];
            d += g[1];
            return "t" + g.join(",");
            break;
          case "M":
            c = g[0];
            d = g[1];
            return "m" + g.join(",");
            break;
          case "l":
            c += g[0];
            d += g[1];
            return "r" + g.join(",");
            break;
          case "L":
            c = g[0];
            d = g[1];
            return "l" + g.join(",");
            break;
          case "h":
            c += g[0];
            return "r" + g[0] + ",0";
            break;
          case "H":
            c = g[0];
            return "l" + c + "," + d;
            break;
          case "v":
            d += g[0];
            return "r0," + g[0];
            break;
          case "V":
            d = g[0];
            return "l" + c + "," + d;
            break;
          case "c":
            e = c + g[g.length - 4];
            f = d + g[g.length - 3];
            c += g[g.length - 2];
            d += g[g.length - 1];
            return "v" + g.join(",");
            break;
          case "C":
            e = g[g.length - 4];
            f = g[g.length - 3];
            c = g[g.length - 2];
            d = g[g.length - 1];
            return "c" + g.join(",");
            break;
          case "s":
            g.unshift(d - f);
            g.unshift(c - e);
            e = c + g[g.length - 4];
            f = d + g[g.length - 3];
            c += g[g.length - 2];
            d += g[g.length - 1];
            return "v" + g.join(",");
            break;
          case "S":
            g.unshift(d + d - f);
            g.unshift(c + c - e);
            e = g[g.length - 4];
            f = g[g.length - 3];
            c = g[g.length - 2];
            d = g[g.length - 1];
            return "c" + g.join(",");
            break;
        }
        return "";
    }).replace(/z/g, "e");
};

jvm.VMLCircleElement = function(a, b) {
    jvm.VMLCircleElement.parentClass.call(this, "oval", a, b);
};

jvm.inherits(jvm.VMLCircleElement, jvm.VMLShapeElement);

jvm.VMLCircleElement.prototype.applyAttr = function(a, b) {
    switch (a) {
      case "r":
        this.node.style.width = b * 2 + "px";
        this.node.style.height = b * 2 + "px";
        this.applyAttr("cx", this.get("cx") || 0);
        this.applyAttr("cy", this.get("cy") || 0);
        break;
      case "cx":
        if (!b) return;
        this.node.style.left = b - (this.get("r") || 0) + "px";
        break;
      case "cy":
        if (!b) return;
        this.node.style.top = b - (this.get("r") || 0) + "px";
        break;
      default:
        jvm.VMLCircleElement.parentClass.prototype.applyAttr.call(this, a, b);
    }
};

jvm.VectorCanvas = function(a, b, c) {
    this.mode = window.SVGAngle ? "svg" : "vml";
    if (this.mode == "svg") {
        this.impl = new jvm.SVGCanvasElement(a, b, c);
    } else {
        this.impl = new jvm.VMLCanvasElement(a, b, c);
    }
    return this.impl;
};

jvm.SimpleScale = function(a) {
    this.scale = a;
};

jvm.SimpleScale.prototype.getValue = function(a) {
    return a;
};

jvm.OrdinalScale = function(a) {
    this.scale = a;
};

jvm.OrdinalScale.prototype.getValue = function(a) {
    return this.scale[a];
};

jvm.NumericScale = function(a, b, c, d) {
    this.scale = [];
    b = b || "linear";
    if (a) this.setScale(a);
    if (b) this.setNormalizeFunction(b);
    if (c) this.setMin(c);
    if (d) this.setMax(d);
};

jvm.NumericScale.prototype = {
    setMin: function(a) {
        this.clearMinValue = a;
        if (typeof this.normalize === "function") {
            this.minValue = this.normalize(a);
        } else {
            this.minValue = a;
        }
    },
    setMax: function(a) {
        this.clearMaxValue = a;
        if (typeof this.normalize === "function") {
            this.maxValue = this.normalize(a);
        } else {
            this.maxValue = a;
        }
    },
    setScale: function(a) {
        var b;
        for (b = 0; b < a.length; b++) {
            this.scale[b] = [ a[b] ];
        }
    },
    setNormalizeFunction: function(a) {
        if (a === "polynomial") {
            this.normalize = function(a) {
                return Math.pow(a, .2);
            };
        } else if (a === "linear") {
            delete this.normalize;
        } else {
            this.normalize = a;
        }
        this.setMin(this.clearMinValue);
        this.setMax(this.clearMaxValue);
    },
    getValue: function(a) {
        var b = [], c = 0, d, e = 0, f;
        if (typeof this.normalize === "function") {
            a = this.normalize(a);
        }
        for (e = 0; e < this.scale.length - 1; e++) {
            d = this.vectorLength(this.vectorSubtract(this.scale[e + 1], this.scale[e]));
            b.push(d);
            c += d;
        }
        f = (this.maxValue - this.minValue) / c;
        for (e = 0; e < b.length; e++) {
            b[e] *= f;
        }
        e = 0;
        a -= this.minValue;
        while (a - b[e] >= 0) {
            a -= b[e];
            e++;
        }
        if (e == this.scale.length - 1) {
            a = this.vectorToNum(this.scale[e]);
        } else {
            a = this.vectorToNum(this.vectorAdd(this.scale[e], this.vectorMult(this.vectorSubtract(this.scale[e + 1], this.scale[e]), a / b[e])));
        }
        return a;
    },
    vectorToNum: function(a) {
        var b = 0, c;
        for (c = 0; c < a.length; c++) {
            b += Math.round(a[c]) * Math.pow(256, a.length - c - 1);
        }
        return b;
    },
    vectorSubtract: function(a, b) {
        var c = [], d;
        for (d = 0; d < a.length; d++) {
            c[d] = a[d] - b[d];
        }
        return c;
    },
    vectorAdd: function(a, b) {
        var c = [], d;
        for (d = 0; d < a.length; d++) {
            c[d] = a[d] + b[d];
        }
        return c;
    },
    vectorMult: function(a, b) {
        var c = [], d;
        for (d = 0; d < a.length; d++) {
            c[d] = a[d] * b;
        }
        return c;
    },
    vectorLength: function(a) {
        var b = 0, c;
        for (c = 0; c < a.length; c++) {
            b += a[c] * a[c];
        }
        return Math.sqrt(b);
    }
};

jvm.ColorScale = function(a, b, c, d) {
    jvm.ColorScale.parentClass.apply(this, arguments);
};

jvm.inherits(jvm.ColorScale, jvm.NumericScale);

jvm.ColorScale.prototype.setScale = function(a) {
    var b;
    for (b = 0; b < a.length; b++) {
        this.scale[b] = jvm.ColorScale.rgbToArray(a[b]);
    }
};

jvm.ColorScale.prototype.getValue = function(a) {
    return jvm.ColorScale.numToRgb(jvm.ColorScale.parentClass.prototype.getValue.call(this, a));
};

jvm.ColorScale.arrayToRgb = function(a) {
    var b = "#", c, d;
    for (d = 0; d < a.length; d++) {
        c = a[d].toString(16);
        b += c.length == 1 ? "0" + c : c;
    }
    return b;
};

jvm.ColorScale.numToRgb = function(a) {
    a = a.toString(16);
    while (a.length < 6) {
        a = "0" + a;
    }
    return "#" + a;
};

jvm.ColorScale.rgbToArray = function(a) {
    a = a.substr(1);
    return [ parseInt(a.substr(0, 2), 16), parseInt(a.substr(2, 2), 16), parseInt(a.substr(4, 2), 16) ];
};

jvm.DataSeries = function(a, b) {
    var c;
    a = a || {};
    a.attribute = a.attribute || "fill";
    this.elements = b;
    this.params = a;
    if (a.attributes) {
        this.setAttributes(a.attributes);
    }
    if (jvm.$.isArray(a.scale)) {
        c = a.attribute === "fill" || a.attribute === "stroke" ? jvm.ColorScale : jvm.NumericScale;
        this.scale = new c(a.scale, a.normalizeFunction, a.min, a.max);
    } else if (a.scale) {
        this.scale = new jvm.OrdinalScale(a.scale);
    } else {
        this.scale = new jvm.SimpleScale(a.scale);
    }
    this.values = a.values || {};
    this.setValues(this.values);
};

jvm.DataSeries.prototype = {
    setAttributes: function(a, b) {
        var c = a, d;
        if (typeof a == "string") {
            if (this.elements[a]) {
                this.elements[a].setStyle(this.params.attribute, b);
            }
        } else {
            for (d in c) {
                if (this.elements[d]) {
                    this.elements[d].element.setStyle(this.params.attribute, c[d]);
                }
            }
        }
    },
    setValues: function(a) {
        var b = Number.MIN_VALUE, c = Number.MAX_VALUE, d, e, f = {};
        if (!(this.scale instanceof jvm.OrdinalScale) && !(this.scale instanceof jvm.SimpleScale)) {
            if (!this.params.min || !this.params.max) {
                for (e in a) {
                    d = parseFloat(a[e]);
                    if (d > b) b = a[e];
                    if (d < c) c = d;
                }
                if (!this.params.min) {
                    this.scale.setMin(c);
                }
                if (!this.params.max) {
                    this.scale.setMax(b);
                }
                this.params.min = c;
                this.params.max = b;
            }
            for (e in a) {
                d = parseFloat(a[e]);
                if (!isNaN(d)) {
                    f[e] = this.scale.getValue(d);
                } else {
                    f[e] = this.elements[e].element.style.initial[this.params.attribute];
                }
            }
        } else {
            for (e in a) {
                if (a[e]) {
                    f[e] = this.scale.getValue(a[e]);
                } else {
                    f[e] = this.elements[e].element.style.initial[this.params.attribute];
                }
            }
        }
        this.setAttributes(f);
        jvm.$.extend(this.values, a);
    },
    clear: function() {
        var a, b = {};
        for (a in this.values) {
            b[a] = this.elements[a].element.style.initial[this.params.attribute];
        }
        this.setAttributes(b);
        this.values = {};
    },
    setScale: function(a) {
        this.scale.setScale(a);
        if (this.values) {
            this.setValues(this.values);
        }
    },
    setNormalizeFunction: function(a) {
        this.scale.setNormalizeFunction(a);
        if (this.values) {
            this.setValues(this.values);
        }
    }
};

jvm.Proj = {
    mill: function(a, b, c) {
        return {
            x: (b - c) / 360 * jvm.WorldMap.circumference,
            y: -(180 / Math.PI * (5 / 4) * Math.log(Math.tan(Math.PI / 4 + 4 / 5 * a * Math.PI / 360))) / 360 * jvm.WorldMap.circumference
        };
    },
    merc: function(a, b, c) {
        return {
            x: (b - c) / 360 * jvm.WorldMap.circumference,
            y: -(180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + a * Math.PI / 360))) / 360 * jvm.WorldMap.circumference
        };
    },
    aea: function(a, b, c) {
        var d = 0, e = c / 180 * Math.PI, f = 29.5 / 180 * Math.PI, g = 45.5 / 180 * Math.PI, h = a / 180 * Math.PI, i = b / 180 * Math.PI, j = (Math.sin(f) + Math.sin(g)) / 2, k = Math.cos(f) * Math.cos(f) + 2 * j * Math.sin(f), l = j * (i - e), m = Math.sqrt(k - 2 * j * Math.sin(h)) / j, n = Math.sqrt(k - 2 * j * Math.sin(d)) / j;
        return {
            x: m * Math.sin(l) / (2 * Math.PI) * jvm.WorldMap.circumference,
            y: -(n - m * Math.cos(l)) / (2 * Math.PI) * jvm.WorldMap.circumference
        };
    },
    lcc: function(a, b, c) {
        var d = 0, e = c / 180 * Math.PI, f = b / 180 * Math.PI, g = 33 / 180 * Math.PI, h = 45 / 180 * Math.PI, i = a / 180 * Math.PI;
        n = Math.log(Math.cos(g) * (1 / Math.cos(h))) / Math.log(Math.tan(Math.PI / 4 + h / 2) * (1 / Math.tan(Math.PI / 4 + g / 2))), F = Math.cos(g) * Math.pow(Math.tan(Math.PI / 4 + g / 2), n) / n, ro = F * Math.pow(1 / Math.tan(Math.PI / 4 + i / 2), n), ro0 = F * Math.pow(1 / Math.tan(Math.PI / 4 + d / 2), n);
        return {
            x: ro * Math.sin(n * (f - e)) / (2 * Math.PI) * jvm.WorldMap.circumference,
            y: -(ro0 - ro * Math.cos(n * (f - e))) / (2 * Math.PI) * jvm.WorldMap.circumference
        };
    }
};

jvm.WorldMap = function(a) {
    var b = this, c;
    this.params = jvm.$.extend(true, {}, jvm.WorldMap.defaultParams, a);
    this.mapData = jvm.WorldMap.maps[this.params.map];
    this.markers = {};
    this.regions = {};
    this.regionsColors = {};
    this.regionsData = {};
    this.container = jvm.$("<div>").css({
        width: "100%",
        height: "100%"
    }).addClass("jvectormap-container");
    this.params.container.append(this.container);
    this.container.data("mapObject", this);
    this.container.css({
        position: "relative",
        overflow: "hidden"
    });
    this.defaultWidth = this.mapData.width;
    this.defaultHeight = this.mapData.height;
    this.setBackgroundColor(this.params.backgroundColor);
    this.onResize = function() {
        b.setSize();
    };
    jvm.$(window).resize(this.onResize);
    for (c in jvm.WorldMap.apiEvents) {
        if (this.params[c]) {
            this.container.bind(jvm.WorldMap.apiEvents[c] + ".jvectormap", this.params[c]);
        }
    }
    this.canvas = new jvm.VectorCanvas(this.container[0], this.width, this.height);
    if ("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch) {
        if (this.params.bindTouchEvents) {
            this.bindContainerTouchEvents();
        }
    } else {
        this.bindContainerEvents();
    }
    this.bindElementEvents();
    this.createLabel();
    this.bindZoomButtons();
    this.createRegions();
    this.createMarkers(this.params.markers || {});
    this.setSize();
    if (this.params.focusOn) {
        if (typeof this.params.focusOn === "object") {
            this.setFocus.call(this, this.params.focusOn.scale, this.params.focusOn.x, this.params.focusOn.y);
        } else {
            this.setFocus.call(this, this.params.focusOn);
        }
    }
    if (this.params.selectedRegions) {
        this.setSelectedRegions(this.params.selectedRegions);
    }
    if (this.params.selectedMarkers) {
        this.setSelectedMarkers(this.params.selectedMarkers);
    }
    if (this.params.series) {
        this.createSeries();
    }
};

jvm.WorldMap.prototype = {
    transX: 0,
    transY: 0,
    scale: 1,
    baseTransX: 0,
    baseTransY: 0,
    baseScale: 1,
    width: 0,
    height: 0,
    setBackgroundColor: function(a) {
        this.container.css("background-color", a);
    },
    resize: function() {
        var a = this.baseScale;
        if (this.width / this.height > this.defaultWidth / this.defaultHeight) {
            this.baseScale = this.height / this.defaultHeight;
            this.baseTransX = Math.abs(this.width - this.defaultWidth * this.baseScale) / (2 * this.baseScale);
        } else {
            this.baseScale = this.width / this.defaultWidth;
            this.baseTransY = Math.abs(this.height - this.defaultHeight * this.baseScale) / (2 * this.baseScale);
        }
        this.scale *= this.baseScale / a;
        this.transX *= this.baseScale / a;
        this.transY *= this.baseScale / a;
    },
    setSize: function() {
        this.width = this.container.width();
        this.height = this.container.height();
        this.resize();
        this.canvas.setSize(this.width, this.height);
        this.applyTransform();
    },
    reset: function() {
        var a, b;
        for (a in this.series) {
            for (b = 0; b < this.series[a].length; b++) {
                this.series[a][b].clear();
            }
        }
        this.scale = this.baseScale;
        this.transX = this.baseTransX;
        this.transY = this.baseTransY;
        this.applyTransform();
    },
    applyTransform: function() {
        var a, b, c, d;
        if (this.defaultWidth * this.scale <= this.width) {
            a = (this.width - this.defaultWidth * this.scale) / (2 * this.scale);
            c = (this.width - this.defaultWidth * this.scale) / (2 * this.scale);
        } else {
            a = 0;
            c = (this.width - this.defaultWidth * this.scale) / this.scale;
        }
        if (this.defaultHeight * this.scale <= this.height) {
            b = (this.height - this.defaultHeight * this.scale) / (2 * this.scale);
            d = (this.height - this.defaultHeight * this.scale) / (2 * this.scale);
        } else {
            b = 0;
            d = (this.height - this.defaultHeight * this.scale) / this.scale;
        }
        if (this.transY > b) {
            this.transY = b;
        } else if (this.transY < d) {
            this.transY = d;
        }
        if (this.transX > a) {
            this.transX = a;
        } else if (this.transX < c) {
            this.transX = c;
        }
        this.canvas.applyTransformParams(this.scale, this.transX, this.transY);
        if (this.markers) {
            this.repositionMarkers();
        }
    },
    bindContainerEvents: function() {
        var a = false, b, c, d = this;
        this.container.mousemove(function(e) {
            if (a) {
                d.transX -= (b - e.pageX) / d.scale;
                d.transY -= (c - e.pageY) / d.scale;
                d.applyTransform();
                b = e.pageX;
                c = e.pageY;
            }
            return false;
        }).mousedown(function(d) {
            a = true;
            b = d.pageX;
            c = d.pageY;
            return false;
        });
        jvm.$("body").mouseup(function() {
            a = false;
        });
        if (this.params.zoomOnScroll) {
            this.container.mousewheel(function(a, b, c, e) {
                var f = jvm.$(d.container).offset(), g = a.pageX - f.left, h = a.pageY - f.top, i = Math.pow(1.3, e);
                d.label.hide();
                d.setScale(d.scale * i, g, h);
                a.preventDefault();
            });
        }
    },
    bindContainerTouchEvents: function() {
        var a, b, c, d = this, e, f, g, h;
        jvm.$(this.container).bind("gesturestart", function(e) {
            a = d.scale;
            b = d.transX;
            c = d.transY;
            return false;
        });
        jvm.$(this.container).bind("gesturechange", function(b) {
            var c = b.originalEvent.scale;
            d.setScale(a * c, g, h);
            d.label.hide();
            return false;
        });
        jvm.$(this.container).bind("touchstart", function(a) {
            var b = a.originalEvent.touches;
            if (b.length == 2) {
                if (b[0].pageX > b[1].pageX) {
                    g = b[1].pageX + (b[0].pageX - b[1].pageX) / 2;
                } else {
                    g = b[0].pageX + (b[1].pageX - b[0].pageX) / 2;
                }
                if (b[0].pageY > b[1].pageY) {
                    h = b[1].pageY + (b[0].pageY - b[1].pageY) / 2;
                } else {
                    h = b[0].pageY + (b[1].pageY - b[0].pageY) / 2;
                }
            }
            e = a.originalEvent.touches[0].pageX;
            f = a.originalEvent.touches[0].pageY;
        });
        jvm.$(this.container).bind("touchmove", function(a) {
            var b;
            if (d.scale != d.baseScale) {
                if (a.originalEvent.touches.length == 1 && e && f) {
                    b = a.originalEvent.touches[0];
                    d.transX -= (e - b.pageX) / d.scale;
                    d.transY -= (f - b.pageY) / d.scale;
                    d.applyTransform();
                    d.label.hide();
                    e = b.pageX;
                    f = b.pageY;
                } else {
                    e = false;
                    f = false;
                }
                return false;
            }
        });
    },
    bindElementEvents: function() {
        var a = this, b;
        this.container.mousemove(function() {
            b = true;
        });
        this.container.delegate("[class~='jvectormap-element']", "mouseover mouseout", function(b) {
            var c = this, d = jvm.$(this).attr("class").indexOf("jvectormap-region") === -1 ? "marker" : "region", e = d == "region" ? jvm.$(this).attr("data-code") : jvm.$(this).attr("data-index"), f = d == "region" ? a.regions[e].element : a.markers[e].element, g = d == "region" ? a.mapData.paths[e].name : a.markers[e].config.name || "", h = jvm.$.Event(d + "LabelShow.jvectormap"), i = jvm.$.Event(d + "Over.jvectormap");
            if (b.type == "mouseover") {
                a.container.trigger(i, [ e ]);
                if (!i.isDefaultPrevented()) {
                    f.setHovered(true);
                }
                a.label.text(g);
                a.container.trigger(h, [ a.label, e ]);
                if (!h.isDefaultPrevented()) {
                    a.label.show();
                    a.labelWidth = a.label.width();
                    a.labelHeight = a.label.height();
                }
            } else {
                f.setHovered(false);
                a.label.hide();
                a.container.trigger(d + "Out.jvectormap", [ e ]);
            }
        });
        this.container.delegate("[class~='jvectormap-element']", "mousedown", function(a) {
            b = false;
        });
        this.container.delegate("[class~='jvectormap-element']", "mouseup", function(c) {
            var d = this, e = jvm.$(this).attr("class").indexOf("jvectormap-region") === -1 ? "marker" : "region", f = e == "region" ? jvm.$(this).attr("data-code") : jvm.$(this).attr("data-index"), g = jvm.$.Event(e + "Click.jvectormap"), h = e == "region" ? a.regions[f].element : a.markers[f].element;
            if (!b) {
                a.container.trigger(g, [ f ]);
                if (e === "region" && a.params.regionsSelectable || e === "marker" && a.params.markersSelectable) {
                    if (!g.isDefaultPrevented()) {
                        if (a.params[e + "sSelectableOne"]) {
                            a.clearSelected(e + "s");
                        }
                        h.setSelected(!h.isSelected);
                    }
                }
            }
        });
    },
    bindZoomButtons: function() {
        var a = this;
        jvm.$("<div/>").addClass("jvectormap-zoomin").text("+").appendTo(this.container);
        jvm.$("<div/>").addClass("jvectormap-zoomout").html("&#x2212;").appendTo(this.container);
        this.container.find(".jvectormap-zoomin").click(function() {
            a.setScale(a.scale * a.params.zoomStep, a.width / 2, a.height / 2);
        });
        this.container.find(".jvectormap-zoomout").click(function() {
            a.setScale(a.scale / a.params.zoomStep, a.width / 2, a.height / 2);
        });
    },
    createLabel: function() {
        var a = this;
        this.label = jvm.$("<div/>").addClass("jvectormap-label").appendTo(jvm.$("body"));
        this.container.mousemove(function(b) {
            var c = b.pageX - 15 - a.labelWidth, d = b.pageY - 15 - a.labelHeight;
            if (c < 5) {
                c = b.pageX + 15;
            }
            if (d < 5) {
                d = b.pageY + 15;
            }
            if (a.label.is(":visible")) {
                a.label.css({
                    left: c,
                    top: d
                });
            }
        });
    },
    setScale: function(a, b, c, d) {
        var e, f = jvm.$.Event("zoom.jvectormap");
        if (a > this.params.zoomMax * this.baseScale) {
            a = this.params.zoomMax * this.baseScale;
        } else if (a < this.params.zoomMin * this.baseScale) {
            a = this.params.zoomMin * this.baseScale;
        }
        if (typeof b != "undefined" && typeof c != "undefined") {
            e = a / this.scale;
            if (d) {
                this.transX = b + this.defaultWidth * (this.width / (this.defaultWidth * a)) / 2;
                this.transY = c + this.defaultHeight * (this.height / (this.defaultHeight * a)) / 2;
            } else {
                this.transX -= (e - 1) / a * b;
                this.transY -= (e - 1) / a * c;
            }
        }
        this.scale = a;
        this.applyTransform();
        this.container.trigger(f, [ a / this.baseScale ]);
    },
    setFocus: function(a, b, c) {
        var d;
        if (typeof a === "string" && this.regions[a]) {
            d = this.regions[a].element.getBBox();
            this.setScale(Math.min(this.width / d.width, this.height / d.height), -(d.x + d.width / 2), -(d.y + d.height / 2), true);
        } else {
            a = a * this.baseScale;
            this.setScale(a, -b * this.defaultWidth, -c * this.defaultHeight, true);
        }
    },
    getSelected: function(a) {
        var b, c = [];
        for (b in this[a]) {
            if (this[a][b].element.isSelected) {
                c.push(b);
            }
        }
        return c;
    },
    getSelectedRegions: function() {
        return this.getSelected("regions");
    },
    getSelectedMarkers: function() {
        return this.getSelected("markers");
    },
    setSelected: function(a, b) {
        var c;
        if (typeof b != "object") {
            b = [ b ];
        }
        if (jvm.$.isArray(b)) {
            for (c = 0; c < b.length; c++) {
                this[a][b[c]].element.setSelected(true);
            }
        } else {
            for (c in b) {
                this[a][c].element.setSelected(!!b[c]);
            }
        }
    },
    setSelectedRegions: function(a) {
        this.setSelected("regions", a);
    },
    setSelectedMarkers: function(a) {
        this.setSelected("markers", a);
    },
    clearSelected: function(a) {
        var b = {}, c = this.getSelected(a), d;
        for (d = 0; d < c.length; d++) {
            b[c[d]] = false;
        }
        this.setSelected(a, b);
    },
    clearSelectedRegions: function() {
        this.clearSelected("regions");
    },
    clearSelectedMarkers: function() {
        this.clearSelected("markers");
    },
    getMapObject: function() {
        return this;
    },
    getRegionName: function(a) {
        return this.mapData.paths[a].name;
    },
    createRegions: function() {
        var a, b, c = this;
        for (a in this.mapData.paths) {
            b = this.canvas.addPath({
                d: this.mapData.paths[a].path,
                "data-code": a
            }, jvm.$.extend(true, {}, this.params.regionStyle));
            jvm.$(b.node).bind("selected", function(a, b) {
                c.container.trigger("regionSelected.jvectormap", [ jvm.$(this).attr("data-code"), b, c.getSelectedRegions() ]);
            });
            b.addClass("jvectormap-region jvectormap-element");
            this.regions[a] = {
                element: b,
                config: this.mapData.paths[a]
            };
        }
    },
    createMarkers: function(a) {
        var b, c, d, e, f, g = this;
        this.markersGroup = this.markersGroup || this.canvas.addGroup();
        if (jvm.$.isArray(a)) {
            f = a.slice();
            a = {};
            for (b = 0; b < f.length; b++) {
                a[b] = f[b];
            }
        }
        for (b in a) {
            e = a[b] instanceof Array ? {
                latLng: a[b]
            } : a[b];
            d = this.latLngToPoint.apply(this, e.latLng || [ 0, 0 ]);
            c = this.canvas.addCircle({
                "data-index": b,
                cx: d.x,
                cy: d.y
            }, jvm.$.extend(true, {}, this.params.markerStyle, {
                initial: e.style || {}
            }), this.markersGroup);
            c.addClass("jvectormap-marker jvectormap-element");
            jvm.$(c.node).bind("selected", function(a, b) {
                g.container.trigger("markerSelected.jvectormap", [ jvm.$(this).attr("data-index"), b, g.getSelectedMarkers() ]);
            });
            if (this.markers[b]) {
                this.removeMarkers([ b ]);
            }
            this.markers[b] = {
                element: c,
                config: e
            };
        }
    },
    repositionMarkers: function() {
        var a, b;
        for (a in this.markers) {
            b = this.latLngToPoint.apply(this, this.markers[a].config.latLng);
            this.markers[a].element.setStyle({
                cx: b.x,
                cy: b.y
            });
        }
    },
    addMarker: function(a, b, c) {
        var d = {}, e = [], f, g;
        d[a] = b;
        for (g = 0; g < c.length; g++) {
            f = {};
            f[a] = c[g];
            e.push(f);
        }
        this.addMarkers(d, e);
    },
    addMarkers: function(a, b) {
        var c;
        b = b || [];
        this.createMarkers(a);
        for (c = 0; c < b.length; c++) {
            this.series.markers[c].setValues(b[c] || {});
        }
    },
    removeMarkers: function(a) {
        var b;
        for (b = 0; b < a.length; b++) {
            this.markers[a[b]].element.remove();
            delete this.markers[a[b]];
        }
    },
    removeAllMarkers: function() {
        var a, b = [];
        for (a in this.markers) {
            b.push(a);
        }
        this.removeMarkers(b);
    },
    latLngToPoint: function(a, b) {
        var c, d = jvm.WorldMap.maps[this.params.map].projection, e = d.centralMeridian, f = this.width - this.baseTransX * 2 * this.baseScale, g = this.height - this.baseTransY * 2 * this.baseScale, h, i, j = this.scale / this.baseScale;
        if (b < -180 + e) {
            b += 360;
        }
        c = jvm.Proj[d.type](a, b, e);
        h = this.getInsetForPoint(c.x, c.y);
        if (h) {
            i = h.bbox;
            c.x = (c.x - i[0].x) / (i[1].x - i[0].x) * h.width * this.scale;
            c.y = (c.y - i[0].y) / (i[1].y - i[0].y) * h.height * this.scale;
            return {
                x: c.x + this.transX * this.scale + h.left * this.scale,
                y: c.y + this.transY * this.scale + h.top * this.scale
            };
        } else {
            return {
                x: 0,
                y: 0
            };
        }
    },
    getInsetForPoint: function(a, b) {
        var c = jvm.WorldMap.maps[this.params.map].insets, d, e;
        for (d = 0; d < c.length; d++) {
            e = c[d].bbox;
            if (a > e[0].x && a < e[1].x && b > e[0].y && b < e[1].y) {
                return c[d];
            }
        }
    },
    createSeries: function() {
        var a, b;
        this.series = {
            markers: [],
            regions: []
        };
        for (b in this.params.series) {
            for (a = 0; a < this.params.series[b].length; a++) {
                this.series[b][a] = new jvm.DataSeries(this.params.series[b][a], this[b]);
            }
        }
    },
    remove: function() {
        this.label.remove();
        this.container.remove();
        jvm.$(window).unbind("resize", this.onResize);
    }
};

jvm.WorldMap.maps = {};

jvm.WorldMap.circumference = 6381372 * Math.PI * 2;

jvm.WorldMap.defaultParams = {
    map: "world_mill_en",
    backgroundColor: "#505050",
    zoomOnScroll: true,
    zoomMax: 8,
    zoomMin: 1,
    zoomStep: 1.6,
    regionsSelectable: false,
    markersSelectable: false,
    bindTouchEvents: true,
    regionStyle: {
        initial: {
            fill: "white",
            "fill-opacity": 1,
            stroke: "none",
            "stroke-width": 0,
            "stroke-opacity": 1
        },
        hover: {
            "fill-opacity": .8
        },
        selected: {
            fill: "yellow"
        },
        selectedHover: {}
    },
    markerStyle: {
        initial: {
            fill: "grey",
            stroke: "#505050",
            "fill-opacity": 1,
            "stroke-width": 1,
            "stroke-opacity": 1,
            r: 5
        },
        hover: {
            stroke: "black",
            "stroke-width": 2
        },
        selected: {
            fill: "blue"
        },
        selectedHover: {}
    }
};

jvm.WorldMap.apiEvents = {
    onRegionLabelShow: "regionLabelShow",
    onRegionOver: "regionOver",
    onRegionOut: "regionOut",
    onRegionClick: "regionClick",
    onRegionSelected: "regionSelected",
    onMarkerLabelShow: "markerLabelShow",
    onMarkerOver: "markerOver",
    onMarkerOut: "markerOut",
    onMarkerClick: "markerClick",
    onMarkerSelected: "markerSelected",
    onZoom: "zoom"
};